using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace TextLibrary
{
    /** 
     * Класс, определяющий методы работы с предложением и его обработку (содержит логику определения предложения)
     * 
     * Отношение наследования (Sentence - LanguageUnit)
     * Отношение реализации (Sentence - IErasable)
     */
    public class Sentence : LanguageUnit, IErasable, ICorrectable
    {
        /** Содержащиеся корректные слова в предложении
         * 
         * Отношение композиции (Sentence - Word)
         */
        public List<Word> containedWords { get; private set; } = new List<Word>();

        // Публичное поле, через которое происходит обращение к приватному (_instance)
        public override string instance
        {
            // При получении значения возвращается хранимое предложение
            get => _instance;

            /** 
             * При установке значения, новое проверяется на принадлежность единице языка "предложение"
             * В случае успешной проверки, записывается в приватное поле для хранения
             * 
             * Признаки предложения:
             * - Последовательность символов не должна быть пустой (содержит одно или несколько слов).
             * - Последовательность символов начинается с заглавной буквы, кавычки (', ") или цифры.
             * - Последовательность символов заканчивается точкой, вопросительным знаком или восклицательным знаком.
             * - Последовательность символов содержит логическое окончание, т.е. не содержит незавершенных конструкций вида:
             *   - "Aaa,."
             *   - "Aaa (."
             *   - и тд.
             * - Предложение является корректным, если выполняются все вышеуказанные условия и каждое слово предложения является корректным.
             */
        set
            {
                // Обработчик ошибок
                ErrorHandler errorHandler = new ErrorHandler();
                // Список найденный корректных слов в предложении
                List<Word> newContainedWords = new List<Word>();
                // Корректность предложения
                bool isCorrect = true;

                /** 
                 * Если не содержит признак начала предложения (заглавная буква, кавычки или цифра), то предполагается,
                 * что передается некорректное предложение
                 * 
                 * ^ в начале - означает, что вся эта конструкция находится в начале строки
                 * [A-ZА-ЯЁ] - означает любую заглавную букву русского или английского алфавита
                 * \' - означает '
                 * \" - означает "
                 * [0-9] - означает любую цифру
                 * 
                 * Итого все это выражение означает что в начале строки должна быть либо заглавная буква, либо кавычка, либо цифра.
                 */
                if (!new Regex("^([A-ZА-ЯЁ]|\'|\"|[0-9])").IsMatch(value))
                {
                    errorHandler.SetError("Неверное начало предложения - \"" + value + "\"");
                    isCorrect = false;
                }
                /** 
                 * Если не содержит признак конца предложения или содержит нелогическое его окончание, то предполагается,
                 * что передается некорректное предложение
                 * 
                 * ^ в начале - означает что вся эта конструкция прижата к началу строки
                 * $ в конце - означает что вся эта конструкция прижата к концу строки
                 * 
                 * .* - означает любой символ 
                 *    Т.е. в начале предложения может идти что угодно, далее это будет проверяться непосредственно в классе предложения и слова
                 *     
                 * В [^(((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+)?]+ знак "(...)+" означает наличие "..." 1 или более раз
                 *    В [^(((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+)?] "[^...]" означает "не ..."
                 *    В (((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+)? знак "(...)?" в конце означает что "..." может присутствовать, а может и нет
                 *    В ((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+ знак "(...)+" означает наличие "..." 1 или более раз
                 *    В (,|\-|\(|\[|{|\s)(?=(\.|!|\?)) первые скобки "(,|\-|\(|\[|{|\s)" означают какой-либо символ из ",", "-", "(", "[", "{", " ", "    "
                 *    В (,|\-|\(|\[|{|\s)(?=(\.|!|\?)) вторые скобки "(?=(\.|!|\?))" означают что первые присутствуют только если за ними идут либо ".", либо "!", либо "?"
                 *    
                 *    Т.е. перед окончанием предложения не может быть ",", "-", "(", "[", "{", " ", "    "
                 *    
                 * (\.|!|\?)+ - означает наличие какого-либо символа из следующих: ".", "!", "?" 1 или более раз
                 * 
                 *     Т.е. в конце предложения должны быть знаки ".", "!" или "?"
                 * 
                 * Итого это регулярное выражение описывает строки вида:
                 * - "aaaa bbb."
                 * - "aaaa bbb!"
                 * - "Aaaa bbb?"
                 * - "Baaa bbb?!..."
                 * - "aaaa bbb?!.!."
                 * - и тд.
                 * И исключает строки вида:
                 * - "aaaa bbb"
                 * - "aaaa bbb ."
                 * - "aaaa bbb,"
                 * - "aaaa bbb,."
                 * - "aaaa bbb -."
                 * - "Aaaa bbb (."
                 * - "Aaaa bbb [ !"
                 * - и тд.
                 * 
                 * x(?=y)
                 * 
                 * aaa b aaa c
                 */
                else if (!new Regex(@"(.*[^(((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+)]+(\.|!|\?)+)$").IsMatch(value))
                {
                    errorHandler.SetError("Неверный конец предложения - \"" + value + "\"");
                    isCorrect = false;
                }

                // Если предложение пока (некорректные слова делаю предложение так же некорректным) корректно, то производится поиск слов в нем
                if (isCorrect)
                {
                    /** 
                     * Проверка каждого отдельного слова преддложения на корректность 
                     *
                     * Сейчас у нас есть предложение вида "Aaaa bbb!." (может и любого другого корректного).
                     * Но оно может содержать пробелы после окончания или перед началом.
                     * Поэтому вызываем метод Trim, а после Split для выделения отдельных слов и прохождения по каждому.
                     * 
                     * Разделение слов происходит пробелом, тем самым выделяя слова вида:
                     * - "aaa"
                     * - "aaa,"
                     * - "(aaa)"
                     * - "aaa-bbb"
                     * - " aaa   "
                     * - "aaa." (последнее слово предложения)
                     * - и др.
                     */
                    foreach (string strWord in value.Trim().Split(' '))
                    {
                        // Удаление лишних символов по краям слова
                        char[] charsToTrimWords = { ' ', '.', '!', '?', ',', '-', '\"', '\'', '(', ')' };
                        string trimmedWord = strWord.Trim(charsToTrimWords);

                        // Исключение пустых слов, которые могли возникнуть при разделении
                        if (!String.IsNullOrEmpty(trimmedWord))
                        {
                            // Создание слова для вызова ошибок его обработки, если они есть (ошибки возникают при присвоении значения)
                            Word word = new Word(trimmedWord);

                            // Если значение было установлено успешно (если слово корректно)
                            if (!word.IsEmpty())
                            {
                                // Добавление его в список содержащихся слов данного предложения
                                newContainedWords.Add(word);
                            }
                            else
                            {
                                // Если не корректно, устанавливаем соответствующий флаг
                                isCorrect = false;
                            }
                        }
                    }
                }

                // Установка нового значения в зависимости от корректности предложения
                if (isCorrect)
                {
                    _instance = value;
                    containedWords = newContainedWords;
                } else
                {
                    _instance = null;
                    containedWords.Clear();
                }
            }
        }

        // Конструктор по умолчанию
        public Sentence()
        {
            // Выключение логирования ошибок
            ErrorHandler.log = false;
            // Установка пустого значения
            Erase();
            // Включение логирования ошибок
            ErrorHandler.log = true;
        }

        // Конструктор класса
        public Sentence(string value)
        {
            /** 
             * Присвоение значения ("value" если оно корректно и "null" - если нет)
             * 
             * Вместе с этим вызываются ошибки, если они есть
             */
            this.instance = value;
        }

        /** 
         * Метод проверки на содержание значения
         * 
         * Отражает корректность текущего значения - предложение корректно, если не пусто
         */
        public bool IsEmpty()
        {
            return String.IsNullOrEmpty(_instance);
        }

        // Метод стирающий значение предложения
        public void Erase()
        {
            this._instance = null;
            containedWords.Clear();
        }

        // Метод устанавливающий в качестве нового значения откорректированное переданное
        public void SetWithCorrecting(string value)
        {
            // Исправленное значение, инициализируем, сразу убирая лишние пробелы по краям, чтобы потом не тратить ресурсы на это
            string correctValue = value.Trim();

            // Содержащиеся в исправленном предложении слова
            List<Word> newContainedWords = new List<Word>();

            /** 
             * Если не содержит признак начала предложения (заглавная буква, кавычки или цифра), то предполагается,
             * что передается некорректное предложение
             */
            if (!new Regex("^([A-ZА-ЯЁ]|\'|\"|[0-9])").IsMatch(correctValue))
            {
                /** 
                 * Если первая буква не заглавная, заменить ее заглавной
                 * 
                 * Это единственное что мы можем исправить в текущем признаке, т.к. добавлять что-то в предложение нельзя,
                 * а заменять или удалять можно
                 */
                if (new Regex("^[a-zа-яё]").IsMatch(correctValue))
                {
                    correctValue = correctValue.Substring(0, 1).ToUpper() + (correctValue.Length > 1 ? correctValue.Substring(1) : "");
                }
                // Если мы не можем исправить предложение - стираем его
                else
                {
                    correctValue = "";
                }
            }

            /** 
             * Если не содержит признак конца предложения или содержит нелогическое его окончание, то предполагается,
             * что передается некорректное предложение
             * 
             * Проверяем сразу после предыдущей проверки (без else), т.к. они не взаимосвязаны (нет перекрытия ошибки)
             */
            if (!new Regex(@"(.*[^(((,|\-|\(|\[|{|\s)(?=(\.|!|\?)))+)]+(\.|!|\?)+)$").IsMatch(correctValue))
            {
                /**
                 * Если предложение без заключающего знака препинания - добавить точку (по умолчанию)
                 */
                if (!new Regex(@"(\.|!|\?)$").IsMatch(correctValue))
                {
                    correctValue = correctValue + '.';
                }

                /**
                 * Сразу проверяем дальше
                 * 
                 * Если перед заключающим знаком препинания есть какой-либо ненужный символ (нелогичное окончание предложения),
                 * убрать этот символ
                 * 
                 * Делаем это во вложенном цикле, чтобы удалить все такие символы
                 */
                while (new Regex(@"(,|\-|\(|\[|{|\s)(\.|!|\?)$").IsMatch(correctValue))
                {
                    correctValue = correctValue.Substring(0, correctValue.Length - 2) + correctValue[correctValue.Length - 1];
                }
            }

            // Если в значении несколько предложений, то оставить только последнее
            char[] endOfSentence = { '.', '!', '?' };
            correctValue = correctValue.Substring(0, correctValue.IndexOfAny(endOfSentence) + 1);

            // Добавление пробелов после тех знаков, после которых это необходимо
            correctValue = Regex.Replace(correctValue, @"(,|\)|\]|})([^\s])", (Match match) => match.Groups[1].Value + " " + match.Groups[2].Value);

            // Добавление пробелов перед теми знаками, перед которыми это необходимо
            correctValue = Regex.Replace(correctValue, @"([^\s])(\(|\[|{)", (Match match) => match.Groups[1].Value + " " + match.Groups[2].Value);

            // Замена нескольких идущих подряд отдельных символов пробелом
            correctValue = Regex.Replace(correctValue, @"\s+(\(|\)|\[|\]|{|}|'|""|,|\.|!|\?)*\s+", (Match match) => " ");

            // Очистка содержащихся слов
            containedWords.Clear();
            // Исправление слов
            correctValue = Regex.Replace(correctValue, @"[^(\s|\(|\)|\[|\]|{|}|'|""|,|\.|!|\?)]+", CorrectWord);

            // Если непосредственное содрежимое предложения отсутствует, удалить его
            if (new Regex(@"^(\.|!|\?)+$").IsMatch(correctValue)) correctValue = "";

            // Установление верного значения
            if (!String.IsNullOrEmpty(correctValue))
            {
                _instance = correctValue;
                containedWords = newContainedWords;
            } else
            {
                Erase();
            }
        }

        private string CorrectWord(Match match) {
            // Создание слова без ошибок
            Word word = new Word();
            word.SetWithCorrecting(match.Value);

            // Если значение было установлено успешно (если слово корректно)
            if (!word.IsEmpty())
            {
                // Добавление слова в список содержащихся слов данного предложения
                containedWords.Add(word);

                // Замена соответствующего слова в исходной строке
                return word.instance;
            }

            // Удаление слова из исходного строки
            return "";
        }
    }
}
